import Emittery from "emittery";
import { writeFileSync } from "node:fs";
import path from "node:path";

import type { Contract } from "@/config/contracts";
import type { LogFilter } from "@/config/logFilters";
import type { Common } from "@/Ponder";
import { Scalar, Schema } from "@/schema/ts-types";
import { ensureDirExists } from "@/utils/exists";

import { buildContractTypes } from "./contract";
import { buildEntityTypes } from "./entity";
import { buildEventTypes } from "./event";
import { formatPrettier } from "./prettier";

const schemaTypeToGqlSchemaType: Record<Scalar, string> = {
  string: "String",
  int: "Int",
  float: "Float",
  boolean: "Boolean",
  bytes: "Bytes",
  bigint: "BigInt",
};

export class CodegenService extends Emittery {
  private common: Common;
  private contracts: Contract[];
  private logFilters: LogFilter[];

  constructor({
    common,
    contracts,
    logFilters,
  }: {
    common: Common;
    contracts: Contract[];
    logFilters: LogFilter[];
  }) {
    super();
    this.common = common;
    this.contracts = contracts;
    this.logFilters = logFilters;
  }

  generateAppFile({ schema }: { schema?: Schema } = {}) {
    const entities = schema?.entities || [];

    const raw = `
      /* Autogenerated file. Do not edit manually. */
  
      import { PonderApp } from "@ponder/core";
      import type { Block, Log, Transaction, Model, ReadOnlyContract } from "@ponder/core";
      import type { AbiParameterToPrimitiveType } from "abitype";
      import type { BlockTag, Hash } from "viem";

      /* ENTITY TYPES */

      ${buildEntityTypes(entities)}
  
      /* CONTRACT TYPES */

      ${buildContractTypes(this.contracts)}

      /* CONTEXT TYPES */

      export type Context = {
        contracts: {
          ${this.contracts
            .map((contract) => `${contract.name}: ${contract.name};`)
            .join("")}
        },
        entities: {
          ${entities
            .map((entity) => `${entity.name}: Model<${entity.name}>;`)
            .join("")}
        },
      }

  
      /* HANDLER TYPES */
    
      ${buildEventTypes(this.logFilters)}

      export const ponder = new PonderApp<AppType>();
    `;

    const final = formatPrettier(raw);

    const filePath = path.join(this.common.options.generatedDir, "index.ts");
    ensureDirExists(filePath);
    writeFileSync(filePath, final, "utf8");

    this.common.logger.debug({
      service: "codegen",
      msg: `Wrote new file at generated/index.ts`,
    });
  }

  generateSchemaFile({ schema }: { schema: Schema }) {
    const header = `
      """ Autogenerated file. Do not edit manually. """
    `;

    const body = `
    type Query {
      ${schema.entities.map(
        (t) =>
          `${t.name.toLowerCase()}(id: ${
            schemaTypeToGqlSchemaType[t.columns.id.type]
          }!, timestamp: Int): ${t.name}
          `
      )}
      ${schema.entities.map(
        (t) =>
          `${t.name.toLowerCase()}s(
            skip: Int = 0
            first: Int = 100
            orderBy: String= "id"
            orderDirection: String = "asc"
            where: ${t.name}Filter
            timestamp: Int
          ): [${t.name}!]!
          `
      )}

    }

      scalar BigInt

      ${schema.entities.map(
        (t) => `type ${t.name} {
        ${Object.keys(t.columns).map(
          (key) => `
          ${key}: ${schemaTypeToGqlSchemaType[t.columns[key].type as Scalar]}${
            t.columns[key].optional === true ? "" : "!"
          }
          `
        )}
      }`
      )}

      ${schema.entities.map(
        (t) => `input ${t.name}Filter {
          ${Object.keys(t.columns).map((key) =>
            // if (t.columns[key].type === "string") {
            t.columns[key].type === "string"
              ? [
                  "",
                  "_not",
                  "_in",
                  "_not_in",
                  "_contains",
                  "_not_contains",
                  "_starts_with",
                  "_ends_with",
                  "_not_starts_with",
                  "_not_ends_with",
                ].map(
                  (postfix) => `
            ${key + postfix}: ${
                    postfix === "_in" || postfix === "_not_in"
                      ? `[${
                          schemaTypeToGqlSchemaType[
                            t.columns[key].type as Scalar
                          ]
                        }]`
                      : schemaTypeToGqlSchemaType[t.columns[key].type as Scalar]
                  }
            `
                )
              : [
                  "",
                  "_not",
                  "_in",
                  "_not_in",
                  "_gt",
                  "_lt",
                  "_gte",
                  "_lte",
                ].map(
                  (postfix) => `
            ${key + postfix}: ${
                    postfix === "_in" || postfix === "_not_in"
                      ? `[${
                          schemaTypeToGqlSchemaType[
                            t.columns[key].type as Scalar
                          ]
                        }]`
                      : schemaTypeToGqlSchemaType[t.columns[key].type as Scalar]
                  }
            `
                )
          )}
      }`
      )}
    `;

    const final = formatPrettier(header + body, { parser: "graphql" });

    const filePath = path.join(
      this.common.options.generatedDir,
      "schema.graphql"
    );
    ensureDirExists(filePath);
    writeFileSync(filePath, final, "utf8");

    this.common.logger.debug({
      service: "codegen",
      msg: `Wrote new file at generated/schema.graphql`,
    });
  }
}
